#!/bin/bash

declare -A settingDescriptors=(
   ["ADB"]="boolean property persist.service.adb.enable"
   ["accessibility"]="boolean database accessibility_enabled secure"
   ["brltty"]="boolean accessibility org.a11y.brltty.android.BrailleService org.a11y.brltty.android"
   ["country"]="territory property persist.sys.country"
   ["developer"]="boolean database development_settings_enabled secure"
   ["foreign"]="boolean database install_non_market_apps secure"
   ["input"]="boolean input .InputService org.nbp.b2g.input"
   ["language"]="language property persist.sys.language"
   ["nolock"]="boolean database lockscreen.disabled secure"
   ["spiel"]="boolean accessibility info.spielproject.spiel.SpielService info.spielproject.spiel"
   ["talkback"]="boolean accessibility .TalkBackService com.google.android.marvin.talkback"
   ["timeout"]="milliseconds database screen_off_timeout system"
)

databasePath="/data/data/com.android.providers.settings/databases/settings.db"
offValue=0
onValue=1

programName="${0##*/}"
programMessage() {
   local message="${1}"

   echo >&2 "${programName}: ${message}"
}

syntaxError() {
   local message="${1}"

   programMessage "${message}"
   exit 2
}

semanticError() {
   local message="${1}"

   programMessage "${message}"
   exit 3
}

internalError() {
   local message="${1}"

   programMessage "${message}"
   exit 4
}

getComponentPackage() {
   local component="${1}"

   echo "${component%/*}"
}

getComponentClass() {
   local component="${1}"

   echo "${component#*/}"
}

makeComponent() {
   local package="${1}"
   local class="${2}"

   echo "${package}/${class}"
}

makeSettingComponent() {
   makeComponent "${settingContainer}" "${settingObject}"
}

executeShellCommand() {
   local output="$(adb shell "${@}")"
   output="${output//$'\r'}"
   [ -z "${output}" ] || echo "${output}"
}

executeDatabaseCommand() {
   local command="${1}"

   executeShellCommand sqlite3 "${databasePath}" "${command}"
}

getDatabaseValue() {
   local table="${1}"
   local property="${2}"

   executeDatabaseCommand "select value from ${table} where name=\"${property}\""
}

setDatabaseValue() {
   local table="${1}"
   local property="${2}"
   local value="${3}"

   executeDatabaseCommand "update ${table} set value="\"${value}\"" where name=\"${property}\""
}

verifyPackageInstalled() {
   local output="$(executeShellCommand pm path "${settingContainer}")"
   [ -n "${output}" ] || semanticError "package not installed: ${settingName}"
}

showSetting_database() {
   getDatabaseValue "${settingContainer}" "${settingObject}"
}

changeSetting_database() {
   setDatabaseValue "${settingContainer}" "${settingObject}" "${settingValue}"
}

getEnabledAccessibilityServices() {
   local services="$(getDatabaseValue secure enabled_accessibility_services)"
   enabledAccessibilityServices=( ${services//:/ } )
}

findEnabledAccessibilityService() {
   enabledAccessibilityServiceIndex=0

   local component
   local package

   for component in "${enabledAccessibilityServices[@]}"
   do
      package="$(getComponentPackage "${component}")"
      [ "${package}" != "${settingContainer}" ] || return
      let "enabledAccessibilityServiceIndex+=1"
   done

   enabledAccessibilityServiceIndex=""
}

showSetting_accessibility() {
   getEnabledAccessibilityServices
   findEnabledAccessibilityService

   if [ -n "${enabledAccessibilityServiceIndex}" ]
   then
      echo "${onValue}"
   else
      echo "${offValue}"
   fi
}

changeSetting_accessibility() {
   getEnabledAccessibilityServices
   findEnabledAccessibilityService

   case "${settingValue}"
   in
      ${offValue})
         [ -n "${enabledAccessibilityServiceIndex}" ] || return
         unset enabledAccessibilityServices["${enabledAccessibilityServiceIndex}"]
         ;;

      ${onValue})
         [ -z "${enabledAccessibilityServiceIndex}" ] || return
         verifyPackageInstalled
         enabledAccessibilityServices+=( "$(makeSettingComponent)" )
         ;;

      *) internalError "unimplemented value: ${settingValue}";;
   esac

   local services="${enabledAccessibilityServices[*]}"
   services="${services// /:}"
   setDatabaseValue secure enabled_accessibility_services "${services}"
}

showSetting_input() {
   local desired="$(makeSettingComponent)"
   local current="$(getDatabaseValue secure default_input_method)"

   if [ "${current}" = "${desired}" ]
   then
      echo "${onValue}"
   else
      echo "${offValue}"
   fi
}

changeSetting_input() {
   local component="$(makeSettingComponent)"

   case "${settingValue}"
   in
      ${offValue})
         executeShellCommand "ime disable ${component}"
         ;;

      ${onValue})
         executeShellCommand "ime enable ${component}"
         executeShellCommand "ime set ${component}"
         ;;

      *) internalError "unimplemented value: ${settingValue}";;
   esac
}

getPropertyValue() {
   local property="${1}"

   executeShellCommand getprop "${property}"
}

setPropertyValue() {
   local property="${1}"
   local value="${2}"

   executeShellCommand setprop "${property}" "${value}"
}

showSetting_property() {
   getPropertyValue "${settingObject}"
}

changeSetting_property() {
   setPropertyValue "${settingObject}" "${settingValue}"
}

verifyValue_boolean() {
   [ "${settingValue}" = "${offValue}" -o "${settingValue}" = "${onValue}" ] || {
      if [[ "${settingValue}" =~ ^(off|no|false)$ ]]
      then
         settingValue="${offValue}"
      elif [[ "${settingValue}" =~ ^(on|yes|true)$ ]]
      then
         settingValue="${onValue}"
      else
         return 1
      fi
   }

   return 0
}

verifyValue_language() {
   [ "${#settingValue}" -ne 2 ] || {
      [ "${settingValue,,*}" != "${settingValue}" ] || {
         return 0
      }
   }

   return 1
}

verifyValue_milliseconds() {
   [[ "${settingValue}" =~ ^(0|1[0-9]*)$ ]] || return 1
   return 0
}

verifyValue_territory() {
   [ "${#settingValue}" -ne 2 ] || {
      [ "${settingValue^^*}" != "${settingValue}" ] || {
         return 0
      }
   }

   return 1
}

getSettingAttributes() {
   local descriptor="${settingDescriptors["${settingName}"]}"
   [ -n "${descriptor}" ] || syntaxError "unknown setting name: ${settingName}";

   local attributes=( ${descriptor} )
   settingType="${attributes[0]}"
   settingClass="${attributes[1]}"
   settingObject="${attributes[2]}"
   settingContainer="${attributes[3]}"
}

showMilliseconds() {
   local value="${1}"
   echo "${value}"
}

showSetting() {
   local value="$("showSetting_${settingClass}")"

   case "${settingType}"
   in
      milliseconds) showMilliseconds "${value}";;
      *) echo "${value}";;
   esac
}

showAllSettings() {
   local settingNames=${!settingDescriptors[*]}
   settingNames="${settingNames// /$'\n'}"
   settingNames="$(echo "${settingNames}" | sort)"

   for settingName in ${settingNames}
   do
      getSettingAttributes
      echo "${settingName}: $(showSetting)"
   done
}

useEmulator=false
deviceSerialNumber=""

while getopts ":d:e" option
do
   case "${option}"
   in
      :) syntaxError "missing option value: -${OPTARG}";;
     \?) syntaxError "unknown option: -${OPTARG}";;
      *) internalError "unimplemented option: -${option}";;
   esac
done
shift $((OPTIND - 1))

[ "${#}" -gt 0 ] || {
   showAllSettings
   exit 0
}

settingName="${1}"
shift 1
getSettingAttributes

[ "${#}" -gt 0 ] || {
   showSetting
   exit 0
}

settingValue="${1}"
shift 1
[ "${#}" -eq 0 ] || syntaxError "too many parameters"

"verifyValue_${settingType}" || syntaxError "invalid setting value: ${settingName}=${settingValue}"
"changeSetting_${settingClass}"
exit 0
